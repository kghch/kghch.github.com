---
layout: post
title: UNIX环境高级编程-读书进度记录
category: reading
---
{% include JB/setup %}

## 第1章 UNIX基础知识 

* **结构**：内核 -> 系统调用 -> shell + 公用函数库 -> 应用程序
* 登录，/etc/passwd文件中的内容， shell的多个实现版本，bash, dash, zsh…
* 绝对路径、相对路径
* **输入和输出 （第三章详细）**
    * 每运行一个新程序时，所有shell为其打开3个文件描述符：标准输入、标准输出、标准错误。若不特殊处理，都链接向终端。
    * 不带缓冲的IO：open, read, wirte, lseek, close，read时自己指定BUFFERSIZE，不同BUFFERSIZE导致不同程序效率 （第三章详细说明）
    * 标准IO：为不带缓冲的IO函数提供了一个带缓冲的接口。使用标准IO函数，无需担心如何选取最佳缓冲区（上述BUFFERSIZE）的大小。
* **程序和进程 （第十二章详细）**
    * 程序存储在磁盘上，内核使用exec函数（7个exec函数之一）将程序读入内存并执行
    * getpid获取进程id
    * 进程控制的主要函数：fork, exec（7种变体), waitpid
        * fork 对父进程返回进程ID，对子进程返回0
        * fork + exec == 某些操作系统所称的产生（spawn）一个新进程
    * 进程 vs 线程
        * 线程共享同一地址空间、文件描述符、栈、以及进程相关的其它属性
        * 线程ID只在它所属的进程内起作用
        * 进程模型&线程模型（第十二章详细说明）
* **出错处理**
    * UNIX系统执行出错时，通常返回负值
    * 整形变量errno，在<errno.h>中定义了所有常量
    * strerror，将errno的值映射为出错消息的字符串，返回字符串指针
    * perror，基于errno的值，在标准错误上产生一条出错消息
    * 一般不直接使用strerror和perror，而是用附录B中的出错函数
    * <error.h>中的出错可分为：致命 & 非致命 ，非致命可进行捕捉处理
* **用户标识**
    * 用户ID=0 为root用户（根用户/超级用户），口令文件 登录名到用户ID的映射。 getuid()
    * 组ID，组名到组ID的映射，组文件/etc/group。 getgid()
    * 用户ID和组ID用数值存储，是为：节省磁盘空间 + 检验权限时进行比较比字符串更快
    * 附属组ID，一个用户可属于多至16个其它的组
* **信号 （第十章详细）**
    * 用于通知进程发生了某种情况
    * 3种处理信号的方式：
        1. 忽略信号，不推荐
        2. 按系统默认方式处理
        3. 提供一函数，信号发生时调用该函数
    * 终端键盘上有2中产生信号的方法：
        1. 中断键（ctrl + c)
        2. 退出键  (ctrl + \ )
    * 调用kill函数也可产生信号
* **时间值**
    * UNIX系统使用过两种时间值：
        1. 日历时间，自1970.01.01 00:00:00 开始至今所累计的秒数值
        2. 进程时间/CPU时间，以时钟滴答计算
    * 度量进程的执行时间，UNIX维护了三个进程时间值，获取方法：time命令
        1. 时钟时间，即墙上时钟时间
        2. 用户CPU时间，执行用户指令所用时间
        3. 系统CPU时间，进程执行内核程序所花时间。
* **系统调用和库函数**
    * 系统调用：程序向内核请求服务的入口点
    * UNIX所用技术是： 为每个系统调用在标准C库中设置一个同名函数，通过标准C调用序列来调用这些函数，然后函数调用相应的内核服务。
    * 通用库函数，如printf
    * 区别：
        * 从用户角度看，其区别不重要
        * （通用库函数中 使用/未使用 了系统函数，或者进行了封装）

`@2017.12.30，用时2h`

## 第2章 UNIX标准及实现
- UNIX标准化 
    - ISO C
    - IEEE POSIX，可移植操作系统接口
    - SUS，是POSIX的超及定义了一些附加接口
    - FIPS
- UNIX系统实现
    - SVR4
    - BSD
    - FreeBSD
    - Linux
    - Mac OS X
    - Solaris
- 限制
    - 编译时限制（如，短整型的最大值是什么），可在头文件中定义。
    - 运行时限制（如，文件名有多少个字符），通过进程调用一个函数获得限制值。
        - 与文件或目录无关的运行时限制（sysconf函数）
        - 与文件或目录有关的运行时限制（pathconf函数，fpathconf函数）
    - ISO C限制，所有编译时限制都在<limits.h>头文件中
    - POSIX限制
    - XSI限制
    - Sysconf, pathconf, fpathconf

## 第3章 文件I/O（不带缓冲的IO）
- **功能**：打开文件，读文件，写文件；常用的5个函数：open, read, write, lseek, close
- **文件描述符**
    - 对内核，所有打开的文件通过`文件描述符`引用。非负整数。
    - 0：标准输入， 1：标准输出， 2：标准错误。 在POSIX.1标准中，0 1 2被替换成定义在<unistd.h>中的符号常量。
    - 很多系统文件描述符的上限是63，早期是19（对单个进程而言）
- **函数open和openat**
    - 返回最小的最小的未用的文件描述符的值
    - Openat比open多一个fd参数，是POSIX.1最新版本中新加的函数，目的在于：1.让线程使用相对路径名打开文件； 2.可以避免TOCTTOU错误
    - TOCTTOU错误：安全漏洞，可颠覆文件系统权限
- **函数creat**
    - 创建一个文件，完全可用`open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)` 代替
- **函数close**
    - 关闭一个打开文件，释放该进程加在该文件上的所有记录锁
    - 当一个进程结束时，内核自动关闭它所有的打开文件
- **函数lseek**
    - 每个打开文件都有`当前文件偏移量`，非负整数，表示从文件开始处计算的字节数
    - 打开文件时，若不指定O_APPEND选项，偏移量被设为0
    - lseek(fd, offset, whence)
        - 不引起任何I/O操作，仅将文件偏移量记录在内核中
        - 显式设置打开文件的偏移量，执行成功则返回新的偏移量
        - 可用来判断所涉及的文件是否可以设置偏移量，若fd指向管道/FIFO/网络套接字，则返回-1
        - 某些设备允许负的偏移量，所以 永远要用`== -1`来判断是否能设置偏移量
        - 文件偏移量可大于文件的当前长度，文件空洞，文件中的空洞不占用磁盘存储
- **函数read**
    - 成功，则返回读到的字节数；出错，返回-1
    - `ssize_t read(int fd, void *buf, size_t nbytes)`
        - ssize_t，带符号整型
        - size_t，不带符号整型
        - void*，通用指针
- **函数write**
- **I/O的效率**
    - 测试所用的文件系统是linux ext4文件系统（磁盘块长度为4096字节），BUFFSIZE在4096字节及以后位置时，效率最高
    - 文件系统，采用`预读`技术，当检测到正顺序读取时，系统试图读入比应用所要求的更多数据。
    - 测试时，每次都使用不同的文件副本，后一次运行不会在前一次运行的高速缓存中找到所需数据。
- **文件共享**
    - UNIX系统支持在不同进程间共享打开文件
    - 内核使用**3种**数据结构表示打开文件，其关系可用下图精确描述。![结构关系.jpeg](https://i.loli.net/2018/01/05/5a4f54ec7ea28.jpeg)
        - 1. 进程-进程表项。每个进程在进程表中有个记录项（PCB？)，记录项包含一张打开文件描述符表，构成：fd标志+文件表项指针
        - 2. 内核-文件表项。内核为所有打开文件维持一张文件表，包含：
            - 文件状态标志
            - 当前文件偏移量
            - 指向该文件v-node表项的指针
        - 3. 文件-v-node表项。每个打开文件都有一个v-node结构，构成：文件类型+操作函数指针+i-node。打开文件时，从磁盘读入内存
            - i-node包括：文件所有者、文件长度、指向磁盘位置的指针
            - Linux没使用v-node，而是使用i-node结构
￼
    - 一个文件被n个独立进程同时打开，就会有n个文件表项？
    - 多个进程同时读取同一文件可正常工作
- **原子操作**
    - 早期UNIX系统不支持open的O_APPEND选项，通过 lseek到EOF + write完成append的功能。
    - Lseek + write是两个操作，非原子，因此会有多进程同时操作时的冲突问题
    - Open时设置O_APPEND标志，会原子操作，避免上述问题
    - pread, pwrite 原子性操作
        - pread，功能上相当于 lseek + read
        - 区别在于：1. 原子性，不会产生中间状态 2.不更新当前文件偏移量
- **函数dup和dup2**
    - int dup(int fd)
    - Int dup2(int fd, int fd2)，相当于close(fd2) + fcntl(fd, F_DUPFD, fd2)
    - 用于复制现有描述符，dup2中的fd2用于指定新描述符的值，若fd2已打开，则先将其关闭
- **函数sync, fsync, fdatasync**
    - 大多数磁盘I/O都通过缓冲区进行。
    - 通常write只是将数据排入队列，实际的写磁盘操作在以后某时刻执行
    - 延迟写(delay write)：向文件写入数据时，内核先将数据复制到缓冲区中，再排入队列，晚些时候再写入内存。
    - 为保证磁盘和缓冲区的内容一致性，UNIX系统提供sync, fsync, fdatasync函数
        - sync(void)， 将**所有修改过的块缓冲区**排入写队列，并返回。update这一系统守护进程会周期性地调用sync，以保证flush
        - fsync(int fd), 只对指定的fd作用，且等待磁盘操作结束才返回
- **函数fcntl**
    - Int fcntl(int fd, int cmd, …)改变已打开文件的属性，有5种功能，通过指定cmd
        - 复制已有fd
        - 获取/设置fd标志
        - 获取/设置文件状态标志 ![文件状态标志.jpeg](https://i.loli.net/2018/01/05/5a4f54fda8e8f.jpeg)
        - 获取/设置异步I/O所有权
        - 获取/设置记录锁
    - 同步写 vs 延迟写
        - 延迟写，先把数据排入到队列，等一定时间/一定量后一次性写入硬盘
        - 同步写，同时写入到硬盘中
        - Fd文件标志中的O_SYNC标志开启后，则使用同步写
- **函数ioctl**
    - 不能用本章上述其它函数表示的I/O操作都能用ioctl表示
    - 终端I/O是使用ioctl最多的地方
- `因为read和write是**在内核执行**，所以称其为不带缓冲的I/O函数`

`@2018.01.05，用时大概3h`
