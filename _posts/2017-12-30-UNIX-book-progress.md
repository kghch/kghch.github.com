---
layout: post
title: UNIX环境高级编程-读书进度记录
category: reading
---
{% include JB/setup %}

## 第1章 UNIX基础知识 

* **结构**：内核 -> 系统调用 -> shell + 公用函数库 -> 应用程序
* 登录，/etc/passwd文件中的内容， shell的多个实现版本，bash, dash, zsh…
* 绝对路径、相对路径
* **输入和输出 （第三章详细）**
    * 每运行一个新程序时，所有shell为其打开3个文件描述符：标准输入、标准输出、标准错误。若不特殊处理，都链接向终端。
    * 不带缓冲的IO：open, read, wirte, lseek, close，read时自己指定BUFFERSIZE，不同BUFFERSIZE导致不同程序效率 （第三章详细说明）
    * 标准IO：为不带缓冲的IO函数提供了一个带缓冲的接口。使用标准IO函数，无需担心如何选取最佳缓冲区（上述BUFFERSIZE）的大小。
* **程序和进程 （第十二章详细）**
    * 程序存储在磁盘上，内核使用exec函数（7个exec函数之一）将程序读入内存并执行
    * getpid获取进程id
    * 进程控制的主要函数：fork, exec（7种变体), waitpid
        * fork 对父进程返回进程ID，对子进程返回0
        * fork + exec == 某些操作系统所称的产生（spawn）一个新进程
    * 进程 vs 线程
        * 线程共享同一地址空间、文件描述符、栈、以及进程相关的其它属性
        * 线程ID只在它所属的进程内起作用
        * 进程模型&线程模型（第十二章详细说明）
* **出错处理**
    * UNIX系统执行出错时，通常返回负值
    * 整形变量errno，在<errno.h>中定义了所有常量
    * strerror，将errno的值映射为出错消息的字符串，返回字符串指针
    * perror，基于errno的值，在标准错误上产生一条出错消息
    * 一般不直接使用strerror和perror，而是用附录B中的出错函数
    * <error.h>中的出错可分为：致命 & 非致命 ，非致命可进行捕捉处理
* **用户标识**
    * 用户ID=0 为root用户（根用户/超级用户），口令文件 登录名到用户ID的映射。 getuid()
    * 组ID，组名到组ID的映射，组文件/etc/group。 getgid()
    * 用户ID和组ID用数值存储，是为：节省磁盘空间 + 检验权限时进行比较比字符串更快
    * 附属组ID，一个用户可属于多至16个其它的组
* **信号 （第十章详细）**
    * 用于通知进程发生了某种情况
    * 3种处理信号的方式：
        1. 忽略信号，不推荐
        2. 按系统默认方式处理
        3. 提供一函数，信号发生时调用该函数
    * 终端键盘上有2中产生信号的方法：
        1. 中断键（ctrl + c)
        2. 退出键  (ctrl + \ )
    * 调用kill函数也可产生信号
* **时间值**
    * UNIX系统使用过两种时间值：
        1. 日历时间，自1970.01.01 00:00:00 开始至今所累计的秒数值
        2. 进程时间/CPU时间，以时钟滴答计算
    * 度量进程的执行时间，UNIX维护了三个进程时间值，获取方法：time命令
        1. 时钟时间，即墙上时钟时间
        2. 用户CPU时间，执行用户指令所用时间
        3. 系统CPU时间，进程执行内核程序所花时间。
* **系统调用和库函数**
    * 系统调用：程序向内核请求服务的入口点
    * UNIX所用技术是： 为每个系统调用在标准C库中设置一个同名函数，通过标准C调用序列来调用这些函数，然后函数调用相应的内核服务。
    * 通用库函数，如printf
    * 区别：
        * 从用户角度看，其区别不重要
        * （通用库函数中 使用/未使用 了系统函数，或者进行了封装）

`@2017.12.30，用时2h`

## 第2章 UNIX标准及实现
- UNIX标准化 
    - ISO C
    - IEEE POSIX，可移植操作系统接口
    - SUS，是POSIX的超及定义了一些附加接口
    - FIPS
- UNIX系统实现
    - SVR4
    - BSD
    - FreeBSD
    - Linux
    - Mac OS X
    - Solaris
- 限制
    - 编译时限制（如，短整型的最大值是什么），可在头文件中定义。
    - 运行时限制（如，文件名有多少个字符），通过进程调用一个函数获得限制值。
        - 与文件或目录无关的运行时限制（sysconf函数）
        - 与文件或目录有关的运行时限制（pathconf函数，fpathconf函数）
    - ISO C限制，所有编译时限制都在<limits.h>头文件中
    - POSIX限制
    - XSI限制
    - Sysconf, pathconf, fpathconf

## 第3章 文件I/O（不带缓冲的IO）
- **功能**：打开文件，读文件，写文件；常用的5个函数：open, read, write, lseek, close
- **文件描述符**
    - 对内核，所有打开的文件通过`文件描述符`引用。非负整数。
    - 0：标准输入， 1：标准输出， 2：标准错误。 在POSIX.1标准中，0 1 2被替换成定义在<unistd.h>中的符号常量。
    - 很多系统文件描述符的上限是63，早期是19（对单个进程而言）
- **函数open和openat**
    - 返回最小的最小的未用的文件描述符的值
    - Openat比open多一个fd参数，是POSIX.1最新版本中新加的函数，目的在于：1.让线程使用相对路径名打开文件； 2.可以避免TOCTTOU错误
    - TOCTTOU错误：安全漏洞，可颠覆文件系统权限
- **函数creat**
    - 创建一个文件，完全可用`open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)` 代替
- **函数close**
    - 关闭一个打开文件，释放该进程加在该文件上的所有记录锁
    - 当一个进程结束时，内核自动关闭它所有的打开文件
- **函数lseek**
    - 每个打开文件都有`当前文件偏移量`，非负整数，表示从文件开始处计算的字节数
    - 打开文件时，若不指定O_APPEND选项，偏移量被设为0
    - lseek(fd, offset, whence)
        - 不引起任何I/O操作，仅将文件偏移量记录在内核中
        - 显式设置打开文件的偏移量，执行成功则返回新的偏移量
        - 可用来判断所涉及的文件是否可以设置偏移量，若fd指向管道/FIFO/网络套接字，则返回-1
        - 某些设备允许负的偏移量，所以 永远要用`== -1`来判断是否能设置偏移量
        - 文件偏移量可大于文件的当前长度，文件空洞，文件中的空洞不占用磁盘存储
- **函数read**
    - 成功，则返回读到的字节数；出错，返回-1
    - `ssize_t read(int fd, void *buf, size_t nbytes)`
        - ssize_t，带符号整型
        - size_t，不带符号整型
        - void*，通用指针
- **函数write**
- **I/O的效率**
    - 测试所用的文件系统是linux ext4文件系统（磁盘块长度为4096字节），BUFFSIZE在4096字节及以后位置时，效率最高
    - 文件系统，采用`预读`技术，当检测到正顺序读取时，系统试图读入比应用所要求的更多数据。
    - 测试时，每次都使用不同的文件副本，后一次运行不会在前一次运行的高速缓存中找到所需数据。
- **文件共享**
    - UNIX系统支持在不同进程间共享打开文件
    - 内核使用**3种**数据结构表示打开文件，其关系可用下图精确描述。![结构关系.jpeg](https://i.loli.net/2018/01/05/5a4f54ec7ea28.jpeg)
        - 1. 进程-进程表项。每个进程在进程表中有个记录项（PCB？)，记录项包含一张打开文件描述符表，构成：fd标志+文件表项指针
        - 2. 内核-文件表项。内核为所有打开文件维持一张文件表，包含：
            - 文件状态标志
            - 当前文件偏移量
            - 指向该文件v-node表项的指针
        - 3. 文件-v-node表项。每个打开文件都有一个v-node结构，构成：文件类型+操作函数指针+i-node。打开文件时，从磁盘读入内存
            - i-node包括：文件所有者、文件长度、指向磁盘位置的指针
            - Linux没使用v-node，而是使用i-node结构
￼
    - 一个文件被n个独立进程同时打开，就会有n个文件表项？
    - 多个进程同时读取同一文件可正常工作
- **原子操作**
    - 早期UNIX系统不支持open的O_APPEND选项，通过 lseek到EOF + write完成append的功能。
    - Lseek + write是两个操作，非原子，因此会有多进程同时操作时的冲突问题
    - Open时设置O_APPEND标志，会原子操作，避免上述问题
    - pread, pwrite 原子性操作
        - pread，功能上相当于 lseek + read
        - 区别在于：1. 原子性，不会产生中间状态 2.不更新当前文件偏移量
- **函数dup和dup2**
    - int dup(int fd)
    - Int dup2(int fd, int fd2)，相当于close(fd2) + fcntl(fd, F_DUPFD, fd2)
    - 用于复制现有描述符，dup2中的fd2用于指定新描述符的值，若fd2已打开，则先将其关闭
- **函数sync, fsync, fdatasync**
    - 大多数磁盘I/O都通过缓冲区进行。
    - 通常write只是将数据排入队列，实际的写磁盘操作在以后某时刻执行
    - 延迟写(delay write)：向文件写入数据时，内核先将数据复制到缓冲区中，再排入队列，晚些时候再写入内存。
    - 为保证磁盘和缓冲区的内容一致性，UNIX系统提供sync, fsync, fdatasync函数
        - sync(void)， 将**所有修改过的块缓冲区**排入写队列，并返回。update这一系统守护进程会周期性地调用sync，以保证flush
        - fsync(int fd), 只对指定的fd作用，且等待磁盘操作结束才返回
- **函数fcntl**
    - Int fcntl(int fd, int cmd, …)改变已打开文件的属性，有5种功能，通过指定cmd
        - 复制已有fd
        - 获取/设置fd标志
        - 获取/设置文件状态标志 ![文件状态标志.jpeg](https://i.loli.net/2018/01/05/5a4f54fda8e8f.jpeg)
        - 获取/设置异步I/O所有权
        - 获取/设置记录锁
    - 同步写 vs 延迟写
        - 延迟写，先把数据排入到队列，等一定时间/一定量后一次性写入硬盘
        - 同步写，同时写入到硬盘中
        - Fd文件标志中的O_SYNC标志开启后，则使用同步写
- **函数ioctl**
    - 不能用本章上述其它函数表示的I/O操作都能用ioctl表示
    - 终端I/O是使用ioctl最多的地方
- `因为read和write是**在内核执行**，所以称其为不带缓冲的I/O函数`

`@2018.01.05，用时大概3h`

## 第4章 文件和目录
- 函数stat，fstat, fstatat, lstat
- 文件类型
    - 普通文件(regular file)
    - 目录文件(directory file)
    - 块特殊文件(block special file)，提供对设备带缓冲的访问
    - 字符特殊文件，提供对设备不带缓冲的访问。系统中所有设备要么是字符特殊文件，要么是块特殊文件。
    - FIFO，用于进程间通信的管道
    - 套接字，进程间通信
    - 符号链接（symbolic link)，指向其它文件

## 第5章 标准I/O库
- **流和FILE对象**
    - 标准IO库的操作围绕流进行，用标准IO库打开/创建文件时，使一个流与文件关联
    - ASCII字符集，一个字符对应一个字节
    - 流的定向，决定读、写字符是单字节还是多字节（字节定向/宽定向）
    - Fwide用于设置流的定向
- **标准输入、标准输出、标准错误**
    - 对一个进程预定义了以上3个流，可自动被进程使用
    - 在头文件<stdio.h>中，通过stdin, stdout和stderr使用
- **缓冲**
    - 目的：尽可能减少read和write调用的次数（??减少IO操作次数吧，write只是排入到队列中？）read, write等文件IO为系统调用，最终为减少系统调用的次数。
    - 标准IO库对每个I/O流自动进行缓冲管理
    - 标准I/O提供三种类型的缓冲：
        - 1. 全缓冲。在填满标准IO缓冲区后才进行实际IO操作。malloc获得需使用的缓冲区。flush是标准IO缓冲区的写操作，将缓冲区中的内容（可能是部分填满）写到磁盘上。
        - 2. 行缓冲。在输入和输出中遇到换行符时，标准IO库执行IO操作。
            - 注意，当缓冲区填满时，即使没遇到换行符，也要进行IO操作
        - 3. 不带缓冲。标准IO库不对字符进行缓冲存储
    - 标准错误流stderr不带缓冲，以便错误能尽快显示
    - 若是指向终端设备的流，则是行缓冲；否则是全缓冲。
    - Setbuf 打开/关闭缓冲机制，setvbuf 设置缓冲类型
    - 一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区
    - Fflush(File *fp)，强制冲洗一个流，使所有未写数据都被传送至内核
- **打开流**
    - fopen, 打开路径名指定的文件
    - freopen，在一个指定的流上打开一个指定的文件。一般用于将一个文件打开为一个预定义的流
    - Fdopen，取一个已有的fd，并使一个标准IO流与此fd关联
    - UNIX内核不区分`文本文件`和`二进制文件`，但在上述函数中指定`type`中的字符b，可以让标准IO系统进行区分。
    - 若多个进程用标准IO的追加写方式打开一个文件（O_APPEND标志），那文件数据还是正确且安全的。（追加写是原子操作）
    - 若流引用系统终端设备，则默认流是行缓冲的；否则，默认都是全缓冲的
    - Fclose关闭一个打开的流，关闭之前，先冲洗，缓冲区中的任何输入数据都被丢弃（？？为何是丢弃，而非进行一次IO写？）
    - 当一个进程正常终止，所有未带写缓冲数据的标准IO流都被冲洗，所有打开的标准IO流都被关闭
- **读和写流**
    - 三种类型的非格式化IO：
        - 1. 每次一个字符的IO, getc, fgetc, getchar, putc, fputc, putchar
        - 2. 每次一行的IO， fgets fputs
        - 3. 直接IO，常用于从二进制文件中读写一个结构
    - 在大多数实现中，每个流在FILE对象中维护了：出错标志 + 文件结束标志
    - Ungetc可以将从流中读取的字符再**压送**回流，读出顺序与押送回顺序相反（队列？）。只是压送到缓冲区中，并没写到底层文件/设备中。
    - char *gets(char *buf);
    - char *fgets(char *restrict buf, int n, FILE *restrict fp);
    - gets从标准输入读，fgets从指定流中读。两个函数都得指定缓冲区地址。会一直读到下一个换行符为止，读入字符被送入缓冲区，若缓冲区长度不够，则只返回一个不完整的行。
    - Gets不推荐使用，因为无法指定缓冲区长度（默认长度多少？），缓冲区溢出漏洞。所以永远使用fgets而非gets
    - fputs将一个以null字节终止的字符串写到**指定的流**，尾端的终止符null不写出。通常在null字节前是一个换行符，但并不要求总是如此。
    - Puts将一个以null字节终止的字符串写到**标准输出**，null不写出，随后再写一个换行符到标准输出。 Puts没有安全隐患，但还是推荐使用fputs自己控制最后一个换行符的输出。
- **标准IO的效率**
    - exit函数会冲洗任何未写的数据，然后关闭所打开的流（详细在8.5节）
    - 标准IO库与直接调用read write函数相比并不慢很多（用户CPU时间是read的10倍）。对于大多数复杂的应用程序，最主要的用户CPU时间是由应用本身的各种处理消耗的，而不是由标准IO例程消耗的。（？？用户CPU时间消耗）
- **二进制IO**
    - fread, fwrite
        - 读/写二进制数组
        - 读/写一个结构
    - 使用二进制IO的问题是，只能用于读在同一系统上已写的数据
- **定位流**
- **格式化IO**
    - 5个printf函数
    - printf, 将格式化数据写入到标准输出
    - fprintf，写到指定的流
    - dprintf，写到指定fd
    - sprintf，写入数组buf。这里当写入长度大于数组长度时会有缓冲区溢出。
    - snprintf，解决上面的缓冲区溢出问题，当大于数组长度时会被丢弃
    - 具体格式化的标志、参数等等，不展开了。
- **实现细节**
    - 每个标准IO流都有一个与其关联的fd，对一个流调用fileno以获得其fd
    - int fileno(FILE *fp)
- **内存流**
- **标准IO的替代软件**
    - 标准IO效率不高，当使用fgets和fputs时，通常需要复制两次数据：1. 内核和标准IO缓冲区间（调用read write时） 2. 在标准IO缓冲区和用户程序的行缓冲区之间。（???）

## 第6章 系统数据文件和信息
- 口令文件 /etc/passwd，组文件 /etc/group
- 口令文件是ASCII文件
    - 用户名：加密口令：数值用户ID：数值组ID：注释：初始工作目录：初始shell
    - 为阻止一用户登录系统，可使用/dev/null，可将登录shell设为/bin/false
    - 使用nobody用户名的目的，任何人都可登录系统，但其用户ID（65534）和组ID（65534）不提供任何特权，只能访问人人皆可读写的文件。
- 阴影口令文件 /etc/shadow
- 附属组，一个用户可以同时属于多个组。
- uname函数返回与主机和操作系统有关的信息

`@2018.01.10 用时大概3小时`
