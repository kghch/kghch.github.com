---
layout: post
title: UNIX编程艺术-读书进度记录
category: reading
---
{% include JB/setup %}

## 第1章 UNIX基础知识 

- **结构**：内核 -> 系统调用 -> shell + 公用函数库 -> 应用程序
- 登录，/etc/passwd文件中的内容， shell的多个实现版本，bash, dash, zsh…
- 绝对路径、相对路径
- **输入和输出 （第三章详细）**
    - 每运行一个新程序时，所有shell为其打开3个文件描述符：标准输入、标准输出、标准错误。若不特殊处理，都链接向终端。
    - 不带缓冲的IO：open, read, wirte, lseek, close，read时自己指定BUFFERSIZE，不同BUFFERSIZE导致不同程序效率 （第三章详细说明）
    - 标准IO：为不带缓冲的IO函数提供了一个带缓冲的接口。使用标准IO函数，无需担心如何选取最佳缓冲区（上述BUFFERSIZE）的大小。
- **程序和进程 （第十二章详细）**
    - 程序存储在磁盘上，内核使用exec函数（7个exec函数之一）将程序读入内存并执行
    - getpid获取进程id
    - 进程控制的主要函数：fork, exec（7种变体), waitpid
        - fork 对父进程返回进程ID，对子进程返回0
        - fork + exec == 某些操作系统所称的产生（spawn）一个新进程
    - 进程 vs 线程
        - 线程共享同一地址空间、文件描述符、栈、以及进程相关的其它属性
        - 线程ID只在它所属的进程内起作用
        - 进程模型&线程模型（第十二章详细说明）
- **出错处理**
    - UNIX系统执行出错时，通常返回负值
    - 整形变量errno，在<errno.h>中定义了所有常量
    - strerror，将errno的值映射为出错消息的字符串，返回字符串指针
    - perror，基于errno的值，在标准错误上产生一条出错消息
    - 一般不直接使用strerror和perror，而是用附录B中的出错函数
    - <error.h>中的出错可分为：致命 & 非致命 ，非致命可进行捕捉处理
- **用户标识**
    - 用户ID=0 为root用户（根用户/超级用户），口令文件 登录名到用户ID的映射。 getuid()
    - 组ID，组名到组ID的映射，组文件/etc/group。 getgid()
    - 用户ID和组ID用数值存储，是为：节省磁盘空间 + 检验权限时进行比较比字符串更快
    - 附属组ID，一个用户可属于多至16个其它的组
- **信号 （第十章详细）**
    - 用于通知进程发生了某种情况
    - 3种处理信号的方式：
        1. 忽略信号，不推荐
        2. 按系统默认方式处理
        3. 提供一函数，信号发生时调用该函数
    - 终端键盘上有2中产生信号的方法：
        1. 中断键（ctrl + c)
        2. 退出键  (ctrl + \ )
    - 调用kill函数也可产生信号
- **时间值**
    - UNIX系统使用过两种时间值：
        1. 日历时间，自1970.01.01 00:00:00 开始至今所累计的秒数值
        2. 进程时间/CPU时间，以时钟滴答计算
    - 度量进程的执行时间，UNIX维护了三个进程时间值，获取方法：time命令
        1. 时钟时间，即墙上时钟时间
        2. 用户CPU时间，执行用户指令所用时间
        3. 系统CPU时间，进程执行内核程序所花时间。
- **系统调用和库函数**
    - 系统调用：程序向内核请求服务的入口点
    - UNIX所用技术是： 为每个系统调用在标准C库中设置一个同名函数，通过标准C调用序列来调用这些函数，然后函数调用相应的内核服务。
    - 通用库函数，如printf
    - 区别：
        - 从用户角度看，其区别不重要
        - （通用库函数中 使用/未使用 了系统函数，或者进行了封装）

`@2017.12.30，用时2h`
